\import Logic.Meta
\import Meta
\import Utils
\import lect04 (funExt)
\import lect09
\open Nat (+, *)

-- 1. Докажите, что предикат isEven разрешим.

\func isEven (n : Nat) => \Sigma (k : Nat) (n = 2 * k)

\func isEven-dec : DecPred isEven => \lam a => impl a
  \where {
    \func impl (n : Nat) : Decide (isEven n) \elim n {
      | 0 => yes (0, idp)
      | suc 0 => no (\case __ \with {
        | (k, n=2k) => \case \elim k, n=2k \with {
          | 0, ()
        }
      })
      | suc (suc n) => \case impl n \with {
        | yes (k, n=2k) => yes (suc k, pmap suc (pmap suc n=2k))
        | no p => no (\case __ \with {
          | (suc k2, n2=2k2) => p (k2, pmap pred (pmap pred n2=2k2))
          | (0, n2=2k2) => contradiction
        })
      }
    }
  }

-- 2. Докажите, что если равенство элементов A разрешимо, то и равенство элементов List A тоже разрешимо.

\instance ListEq {A : \Type} (dec : Eq A) : Eq (List A)
  | decideEq => {?}

-- 3. Докажите, что функции FromBoolToDec и FromDecToBool взаимно обратны.

\func bdb {A : \Type} (p : A -> Bool) : FromDecToBool (FromBoolToDec p) = p => funExt (\lam _ => Bool) (
  \lam a =>
      \case p a \as pa \return (
        (\case
          (\case pa \as x \return Decide (T x) \with {
            | true => yes ()
            | false => no (\lam x => x)
          })
        \with {
          | yes _ => true
          | no _ => false
        }) = pa
      )
      \with {
        -- unfold (FromDecToBool, FromBoolToDec) {?}
        | true => idp
        | false => idp
      }
)

-- Мы не можем доказать, что FromBoolToDec (FromDecToBool P) = P, но мы можем доказать более слабое утверждение: эти предикаты логически эквивалентны.
-- Для этого введем эквивалентность предикатов.

\func dbd {A : \Type} (P : \Sigma (P : A -> \Type) (DecPred P))
  : \Pi (x : A) -> (FromBoolToDec (FromDecToBool P)).1 x <-> P.1 x
  => {?}

-- 4. Укажите явно чему равен уровень в каждом из вызовов id' ниже.
--    Напишите явно чему равны типы всех функций idTest*.

\func id' {A : \Type} (a : A) => a

\func idTest1 => id' (id' id)
\func idTest2 => id' Maybe
\func idTest3 => id' Functor
\func idTest4 => id' (Functor Maybe)
\func idTest5 (f : \Pi {A B : \Set} -> (A -> B) -> Maybe A -> Maybe B) => id' (Functor Maybe f)

-- 5. Докажите следующий принцип индукции для списков.

\func List-ind
  {A : \Type}
  (E : List A -> \Type)
  (r : \Pi (xs : List A) -> (\Pi (ys : List A) -> length ys < length xs -> E ys) -> E xs)
  (xs : List A) : E xs => {?}

-- 6. Определите div через Nat-ind.

\func div (n k : Nat) (p : 0 < k) : Nat => {?}
